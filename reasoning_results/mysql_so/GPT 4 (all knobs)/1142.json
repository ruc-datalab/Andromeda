{"res": "Based on the details provided about your MySQL 5.6.36 setup on CentOS 7.3 with 48G of RAM, and the issues you are facing with memory usage and server crashes, here are some recommended parameters to adjust in your configuration:\n\n1. **innodb_buffer_pool_size**: You've set this to 18G, which is generally recommended to be about 70-80% of your total RAM if MySQL is the primary application on the server. Given your server has 48G of RAM, you might consider increasing this slightly, but since you're experiencing high memory usage, it's also crucial to ensure that other configurations are optimized to avoid excessive memory consumption.\n\n2. **innodb_buffer_pool_instances**: Currently set to 9. This setting is generally recommended to be set to 1 per every 1GB of `innodb_buffer_pool_size`. Since you have 18G, this setting seems appropriate. However, if you adjust the `innodb_buffer_pool_size`, you should adjust this parameter accordingly.\n\n3. **innodb_log_file_size**: Set at 1G, which might be too low depending on your workload. Increasing this can help reduce the I/O load by reducing the frequency of log flushes to disk. Consider increasing it to about 2G or more, depending on the transaction volume.\n\n4. **max_connections**: Set to 300. Ensure this setting is aligned with your typical workload. Too high a value can lead to excessive memory use, while too low a value can cause too many connection errors under high load.\n\n5. **table_definition_cache**: Set to 2000. Given the number of tables and partitions, you might need to increase this value to reduce the overhead of opening tables.\n\n6. **innodb_file_per_table**: Currently enabled. This setting helps in managing disk space more efficiently by storing each InnoDB table and its indexes in its own file. However, it can increase the number of file descriptors that MySQL requires. Given your large number of tables, consider the implications of file descriptor usage and disk I/O.\n\n7. **innodb_flush_method**: Consider setting this to `O_DIRECT` to avoid double buffering between the MySQL cache and the OS cache.\n\n8. **innodb_io_capacity** and **innodb_io_capacity_max**: These settings should be adjusted based on your underlying storage performance capabilities. They control the I/O rate for background tasks such as flushing pages from the buffer pool.\n\n9. **innodb_thread_concurrency**: This parameter might need tuning based on your workload. It controls the maximum number of threads that can be running inside InnoDB. The default value is 0 (no limit), but setting it to a specific value might help in controlling thread usage and system stability.\n\n10. **innodb_read_io_threads** and **innodb_write_io_threads**: These settings control the number of I/O threads for read and write operations. Increasing these values can improve I/O throughput, especially on systems with SSDs or multiple disks.\n\nHere is the list of parameters based on your scenario:\n\n```json\n[\n    \"innodb_buffer_pool_size\",\n    \"innodb_buffer_pool_instances\",\n    \"innodb_log_file_size\",\n    \"max_connections\",\n    \"table_definition_cache\",\n    \"innodb_file_per_table\",\n    \"innodb_flush_method\",\n    \"innodb_io_capacity\",\n    \"innodb_io_capacity_max\",\n    \"innodb_thread_concurrency\",\n    \"innodb_read_io_threads\",\n    \"innodb_write_io_threads\"\n]\n```\n\nAdjusting these parameters should help in optimizing the performance and stability of your MySQL server. Always ensure to monitor the changes after each adjustment to see the impact and avoid negative effects."}