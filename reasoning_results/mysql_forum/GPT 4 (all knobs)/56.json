{"res": "Based on your description, it seems you are facing significant performance issues with the EAV model as your database scales. The EAV model, while flexible, often leads to performance bottlenecks and complexity in querying as the data grows, which you've experienced firsthand. Here are some database parameters and strategies you might consider to optimize performance without completely restructuring your database into separate tables for each group, which could lead to maintenance challenges:\n\n1. **innodb_buffer_pool_size**: Increasing this parameter can help improve the performance of InnoDB tables by keeping more data in memory, reducing disk I/O.\n\n2. **innodb_flush_log_at_trx_commit**: Setting this to 2 can improve write performance but at a slight risk of data loss in the event of a crash.\n\n3. **query_cache_size** (if using MySQL < 5.7 as query cache is deprecated in later versions): Enabling and tuning the query cache can help improve performance for read-heavy workloads with relatively static data.\n\n4. **table_open_cache** and **table_definition_cache**: Increasing these values can help when you have a large number of tables and frequent open/close operations.\n\n5. **tmp_table_size** and **max_heap_table_size**: If temporary tables are used extensively in your queries, increasing these values can allow larger temporary tables to reside in memory rather than on disk.\n\n6. **innodb_file_per_table**: Enabling this can improve performance by allowing InnoDB to store data and indexes of each table in separate files, which can be managed more efficiently.\n\nGiven your scenario, here are some strategic recommendations:\n\n- **Materialized Views**: Instead of creating separate tables for each group, consider using materialized views that can be refreshed periodically. This approach maintains the flexibility of the EAV model while providing faster read access.\n\n- **Hybrid Approach**: Maintain the EAV model for data that doesn't require high-performance access and use normalized tables for data that is frequently accessed and performance-critical.\n\n- **Partitioning**: If you decide to stick with the EAV model, consider partitioning the EAV table based on groups or other logical divisions to improve query performance.\n\n- **Caching Layer**: Implement an external caching layer (like Redis or Memcached) to cache frequent queries or data sets, reducing the load on the database.\n\nHere's the list of recommended parameters based on the above discussion:\n\n```json\n[\n    \"innodb_buffer_pool_size\",\n    \"innodb_flush_log_at_trx_commit\",\n    \"query_cache_size\",\n    \"table_open_cache\",\n    \"table_definition_cache\",\n    \"tmp_table_size\",\n    \"max_heap_table_size\",\n    \"innodb_file_per_table\"\n]\n```\n\nThese parameters and strategies should help mitigate some of the performance issues you're experiencing with the EAV model while avoiding the complexity of managing hundreds of separate tables."}