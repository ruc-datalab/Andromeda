{"res": "In the context of PostgreSQL and the `EXPLAIN` command, a \"plain Filter condition\" in an outer join typically comes from the `WHERE` clause of the query. This condition is applied to the results after the outer join has been processed, unlike the \"Join Filter conditions\" which are derived from the `ON` clause of the join itself.\n\nHere are some examples to illustrate the difference:\n\n1. **Outer Join with Join Filter and Plain Filter:**\n   ```sql\n   SELECT *\n   FROM table1\n   LEFT OUTER JOIN table2 ON table1.id = table2.id  -- Join Filter condition\n   WHERE table2.column IS NOT NULL;  -- Plain Filter condition\n   ```\n   In this example:\n   - The \"Join Filter\" is `table1.id = table2.id`, which determines how rows from `table1` and `table2` are matched.\n   - The \"Plain Filter\" is `table2.column IS NOT NULL`, which is applied to the rows after the join has been processed. This filter will remove any rows that, after the join, have a NULL in `table2.column`.\n\n2. **Outer Join with Multiple Conditions:**\n   ```sql\n   SELECT *\n   FROM table1\n   LEFT OUTER JOIN table2 ON table1.id = table2.id AND table2.status = 'active'  -- Join Filter conditions\n   WHERE table1.date > '2023-01-01';  -- Plain Filter condition\n   ```\n   In this example:\n   - The \"Join Filter\" conditions are `table1.id = table2.id` and `table2.status = 'active'`, which are used to match and filter rows during the join.\n   - The \"Plain Filter\" is `table1.date > '2023-01-01'`, which filters the result after the join based on the date field of `table1`.\n\nRegarding the parameters from the documentation provided:\n- `enable_mergejoin`: This parameter controls whether the query planner should consider using merge joins.\n- `enable_nestloop`: This parameter influences the planner's use of nested-loop join plans.\n\nGiven the context of your question and the focus on join operations and planning, the recommended parameters are:\n```json\n['enable_nestloop', 'enable_mergejoin']\n```"}